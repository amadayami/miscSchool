#include "hw3_src/compute_pi.hpp"

void* compute_pi(void* arg)
{
    thread_data_t* data = (thread_data_t*)(arg);
    int thread_id = data->thread_id;
    calc_t* pi_data = data->pi_calc;

    srand(thread_id * time(NULL));
    
    int num_samples = pi_data->global_n_samples;
    int num_threads = pi_data->global_n_threads;
    int per_thread = num_samples/num_threads;
    int remain = num_samples % num_threads;

    lock(&(pi_data->lock));
    //critical section
    int thread_samples;
    if(remain > 0){
        thread_samples = per_thread + 1;
        remain--;
    }
    //git pull origin main --allow-unrelated-histories
    else thread_samples = per_thread;

    int thread_sum = 0;

    for(int i = 0; i < thread_samples; i++){
      double x = (double)rand() / RAND_MAX;
      x = (-1) + x*(1 - (-1));
      double y = (double)rand() / RAND_MAX;
      y = (-1) + y*(1 - (-1));
      
      if((x*x)+(y*y) <= 1){
        thread_sum++;
      }
    }
    pi_data->global_sum = pi_data->global_sum + thread_sum;
    //critical section
    unlock(&(pi_data->lock));

    return NULL;
}

